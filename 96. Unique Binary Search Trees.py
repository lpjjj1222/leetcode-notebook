class Solution:
    def numTrees(self, n: int) -> int:
        #注意二叉搜索树，左树所有节点比根节点小，右树所有节点比根节点大
        #dp数组的意义：dp[i]为节点数为i的树的unique structure数，也可以是，长度为i的子树的unique structure数

        #创建dp数组
        dp = [0] * (n+1)

        if n <= 2:
            return n

        #dp[0]即长度为0的子树，即空子树，一共就一种情况
        dp[0] = 1
        #dp[1]即长度为1的子树，一共就一种情况
        dp[1] = 1
        #dp[2]即长度为2的子树，一共两种情况
        dp[2] = 2

        #要求dp[3]，可以分别确定根节点为不同数字，然后长度为某个数的左子树的structure可能性 * 右子树长度为某个数的structure可能性得到一共可能性数
        #根节点为1，左子树必空，右子树长度必为2，因此dp[0] * dp[2] = 1*2 = 2
        #根节点为2，左子树长度为1，右子树长度为1，因此dp[1] * dp[1] = 1*1 = 1
        #根节点为3，左子树长度为2，右子树必空，因此dp[2] * dp[0] = 2*1 =2
        #将所有情况相加，即2+1+2 = 5

        #对于dp[i], 如果j为根节点，则j-1为左子树长度，因为比j小的数都要放在左边，则右子树长度为i-（j-1）-1即i-j

        for i in range(3,n+1):
            for j in range(1, i+1): #分别遍历根节点为i,i-1, i-2...的情况
                dp[i] += dp[j-1] * dp[i-j]
        
        return dp[n]


        
